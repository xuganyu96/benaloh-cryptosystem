//! This is the proof in which the prover tries to conveince the verifier that the statement is
//! an r-th residue
//!
//! statement: z = x^r
//! commitment: z' = (x')^r
//! challenge: b <- Z/r
//! response x'x^b
//! verification: response^r = z'z^b
//!
//! In addition, a Fiat-Shamir transformation is applied so the challenge is generated by hasing
//! the commitment, so the entire proof can be performed offline

use crate::{
    arithmetics::{self, ClearResidue},
    keys::PublicKey,
    BigInt, LIMBS,
};
use crypto_bigint::{
    modular::runtime_mod::{DynResidue, DynResidueParams},
    Encoding,
};
use sha3::{Digest, Sha3_256};

/// Statement and commmit are elements of multiplicative gropu Z/n
/// Challenge is an element of the ring Z/r
pub struct Proof {
    statement: ClearResidue,
    commitment: ClearResidue,
}

impl Proof {
    pub fn get_statement(&self) -> &ClearResidue {
        return &self.statement;
    }

    pub fn get_commitment(&self) -> &ClearResidue {
        return &self.commitment;
    }

    /// Generate a random r-th residue by sampling a random invertible element and raising it to
    /// the r-th power
    pub fn generate_commitment(n: DynResidueParams<LIMBS>, ambience: &PublicKey) -> ClearResidue {
        let x_prime = arithmetics::sample_invertible(n);
        let zero = DynResidue::new(&BigInt::ZERO, ambience.get_r().to_dyn_residue_params());
        return ClearResidue::compose(zero, x_prime, ambience);
    }

    /// Hash the commitment by hashing the big-endian byte representation, then convert the hash
    /// back into a big integer and take (mod r)
    pub fn generate_challenge(commitment: &ClearResidue, r: &BigInt) -> DynResidue<LIMBS> {
        let commitment: Vec<u8> = commitment.get_val().retrieve().to_be_bytes().to_vec();
        let mut hasher = Sha3_256::new();
        hasher.update(&commitment);
        let hash: Vec<u8> = hasher.finalize().to_vec();

        let r = DynResidueParams::new(r);
        let challenge = DynResidue::new(&BigInt::from_be_slice(&hash), r);
        return challenge;
    }

    /// Provide a response
    pub fn respond(
        statement: &ClearResidue,
        commitment: &ClearResidue,
        challenge: &DynResidue<LIMBS>,
    ) -> DynResidue<LIMBS> {
        return statement
            .get_witness()
            .pow(&challenge.retrieve())
            .mul(commitment.get_witness());
    }

    pub fn verify(
        statement: &ClearResidue,
        commitment: &ClearResidue,
        challenge: &DynResidue<LIMBS>,
        response: &DynResidue<LIMBS>,
        ambience: &PublicKey,
    ) -> bool {
        let lhs = response.pow(ambience.get_r().modulus());
        let rhs = statement
            .get_val()
            .pow(&challenge.retrieve())
            .mul(commitment.get_val());

        return lhs.retrieve() == rhs.retrieve();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::keys::KeyPair;

    #[test]
    fn test_correctness() {
        let keypair = KeyPair::keygen(16, 64, false);
        let n = DynResidueParams::new(keypair.get_pk().get_n());
        let zero = DynResidue::new(
            &BigInt::ZERO,
            keypair.get_pk().get_r().to_dyn_residue_params(),
        );
        let witness = arithmetics::sample_invertible(n);
        let statement = ClearResidue::compose(zero, witness, keypair.get_pk());
        let commitment = Proof::generate_commitment(n, keypair.get_pk());
        let challenge = Proof::generate_challenge(&commitment, keypair.get_pk().get_r().modulus());
        let response = Proof::respond(&statement, &commitment, &challenge);
        let validated = Proof::verify(
            &statement,
            &commitment,
            &challenge,
            &response,
            keypair.get_pk(),
        );
        assert!(validated);
    }
}
