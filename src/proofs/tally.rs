//! This is the proof in which the prover tries to conveince the verifier that the statement is
//! an r-th residue
//!
//! statement: z = x^r
//! commitment: z' = (x')^r
//! challenge: b <- Z/r
//! response x'x^b
//! verification: response^r = z'z^b
//!
//! In addition, a Fiat-Shamir transformation is applied so the challenge is generated by hasing
//! the commitment, so the entire proof can be performed offline
use crate::{
    arithmetics::{ClearResidue, OpaqueResidue, ResidueClass},
    keys::PublicKey,
    BigInt,
};
use crypto_bigint::{modular::runtime_mod::DynResidue, Encoding};
use sha3::{Digest, Sha3_256};

/// Proof that the tally is correct by showing that wy^(-c) is an r-th residue, including the
/// Fiat-Shamir transformation so that it is non-interactive
/// statement: z = x ** r
/// commitment: z' = x' ** r
/// challenge: b <- Z/r
/// response: x'x ** b
/// verify: response ** r = z'z ** b
pub struct TallyProof {
    pub statement: OpaqueResidue,
    pub commitment: Vec<OpaqueResidue>,
    pub challenge: Vec<ResidueClass>,

    /// The response will actually be (x'x ** b) ** r for easier verification
    pub response: Vec<ClearResidue>,
}

impl TallyProof {
    pub fn new(
        statement: OpaqueResidue,
        commitment: Vec<OpaqueResidue>,
        challenge: Vec<ResidueClass>,
        response: Vec<ClearResidue>,
    ) -> Self {
        return Self {
            statement,
            commitment,
            challenge,
            response,
        };
    }

    pub fn from_statement(statement: ClearResidue, confidence: usize, pk: &PublicKey) -> Self {
        let commitment = Self::generate_commitment(confidence, pk);
        let challenge = Self::generate_challenge(&commitment, pk);
        let response = Self::respond(&statement, &commitment, &challenge);

        // Need to obscure the statement and the commiment for zero-knowledge property
        let statement = statement.clone_val();
        let commitment: Vec<OpaqueResidue> =
            commitment.iter().map(|clear| clear.clone_val()).collect();
        return Self::new(statement, commitment, challenge, response);
    }

    /// Verify that (x' * (x ** b)) ** r is indeed z'z**b
    pub fn verify(&self) -> bool {
        if self.commitment.len() != self.response.len() {
            return false;
        }
        // Unfortunately not easily made into functional due to needing three iterators
        let mut verified = true;
        for (i, response) in self.response.iter().enumerate() {
            let lhs = response.clone_val();
            let commitment = self.commitment.get(i).unwrap().clone();
            let challenge = self.challenge.get(i).unwrap();
            let rhs = commitment * self.statement.pow(challenge);
            if lhs != rhs {
                verified = false;
            }
        }
        return verified;
    }

    /// Generate random r-th residues
    fn generate_commitment(confidence: usize, pk: &PublicKey) -> Vec<ClearResidue> {
        return (0..confidence)
            .map(|_| {
                let zero = DynResidue::new(&BigInt::ZERO, pk.get_r().to_dyn_residue_params());
                return ClearResidue::random(Some(zero), pk);
            })
            .collect::<Vec<ClearResidue>>();
    }

    /// Hash the commitment (element of Z/n) into a residue class (element of Z/r)
    fn hash_commitment(commitment: &ClearResidue, pk: &PublicKey) -> ResidueClass {
        let mut hasher = Sha3_256::new();
        hasher.update(commitment.get_val().retrieve().to_be_bytes());
        let hash: Vec<u8> = hasher.finalize().to_vec();
        let class = ResidueClass::from_be_bytes(&hash, pk.get_r());
        return class;
    }

    /// Hash each residue into a residue class
    fn generate_challenge(commitment: &[ClearResidue], pk: &PublicKey) -> Vec<ResidueClass> {
        return commitment
            .iter()
            .map(|z_prime| Self::hash_commitment(z_prime, pk))
            .collect();
    }

    /// For each challenge, return (x'x ** b) ** r. However since we need to raise the response
    /// to the r-th power anyways, we actually return z'z**b but with its decomposition
    fn respond(
        statement: &ClearResidue,
        commitment: &[ClearResidue],
        challenge: &[ResidueClass],
    ) -> Vec<ClearResidue> {
        return commitment
            .iter()
            .zip(challenge.iter())
            .map(|(z_prime, b)| statement.pow(b).clone() * z_prime.clone())
            .collect();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::keys::KeyPair;

    #[test]
    fn test_tally_proof_correctness() {
        let keypair = KeyPair::keygen(16, 64, false);
        let zero = DynResidue::new(
            &BigInt::ZERO,
            keypair.get_pk().get_r().to_dyn_residue_params(),
        );
        let statement = ClearResidue::random(Some(zero), keypair.get_pk());
        let proof = TallyProof::from_statement(statement, 16, keypair.get_pk());
        assert!(proof.verify());
    }
}
